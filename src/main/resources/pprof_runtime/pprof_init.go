// Code generated by pprofview plugin. DO NOT EDIT.
// This file is automatically injected to enable pprof profiling.

package main

import (
	"fmt"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"runtime/trace"
	"strconv"
	"syscall"
	"time"
)

var (
	pprofCleanupFunc func()
	pprofCpuFile     *os.File
	pprofTraceFile   *os.File
	pprofOutputDir   string
)

func init() {	
	outputDir := os.Getenv("PPROF_OUTPUT_DIR")
	if outputDir == "" {
		log.Println("[pprofview] PPROF_OUTPUT_DIR environment variable not set, skipping pprof collection")
		return
	}
	
	pprofOutputDir = outputDir
	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Printf("[pprofview] Cannot create output directory: %v", err)
		return
	}
	
	// Set sampling rates
	if memRateStr := os.Getenv("PPROF_MEM_RATE"); memRateStr != "" {
		if memRate, err := strconv.Atoi(memRateStr); err == nil && memRate > 0 {
			runtime.MemProfileRate = memRate
			log.Printf("[pprofview] Memory profile rate: %d", memRate)
		}
	}
	
	if blockRateStr := os.Getenv("PPROF_BLOCK_RATE"); blockRateStr != "" {
		if blockRate, err := strconv.Atoi(blockRateStr); err == nil && blockRate > 0 {
			runtime.SetBlockProfileRate(blockRate)
			log.Printf("[pprofview] Block profile rate: %d", blockRate)
		}
	}
	
	if mutexFractionStr := os.Getenv("PPROF_MUTEX_FRACTION"); mutexFractionStr != "" {
		if mutexFraction, err := strconv.Atoi(mutexFractionStr); err == nil && mutexFraction > 0 {
			runtime.SetMutexProfileFraction(mutexFraction)
			log.Printf("[pprofview] Mutex profile rate: %d", mutexFraction)
		}
	}
	
	// CPU profiling
	if os.Getenv("PPROF_ENABLE_CPU") == "true" {
		cpuFilePath := filepath.Join(outputDir, "cpu.pprof")
		f, err := os.Create(cpuFilePath)
		if err != nil {
			log.Printf("[pprofview] Cannot create CPU profile file: %v", err)
		} else {
			if err := pprof.StartCPUProfile(f); err != nil {
				f.Close()
			} else {
				pprofCpuFile = f
			}
		}
	}
	
	// Execution trace
	if os.Getenv("PPROF_ENABLE_TRACE") == "true" {
		traceFilePath := filepath.Join(outputDir, "trace.out")
		f, err := os.Create(traceFilePath)
		if err != nil {
			log.Printf("[pprofview] Cannot create trace file: %v", err)
		} else {
			if err := trace.Start(f); err != nil {
				f.Close()
			} else {
				pprofTraceFile = f
			}
		}
	}
	
	// Set cleanup function
	pprofCleanupFunc = func() {
		log.Println("[pprofview] Saving pprof data...")
		if pprofCpuFile != nil {
			pprof.StopCPUProfile()
			pprofCpuFile.Close()
			log.Printf("[pprofview] CPU profiling completed")
		}
		if pprofTraceFile != nil {
			trace.Stop()
			pprofTraceFile.Close()
			log.Printf("[pprofview] Trace completed")
		}
		writePprofProfiles(pprofOutputDir)
		log.Println("[pprofview] All pprof data saved")
	}
	
	// Capture interrupt signals
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	
	go func() {
		<-sigChan
		log.Println("[pprofview] Received exit signal, saving pprof data...")
		if pprofCleanupFunc != nil {
			pprofCleanupFunc()
		}
		os.Exit(0)
	}()
	
	// Get sampling configuration
	cpuDuration := 30
	if durationStr := os.Getenv("PPROF_CPU_DURATION"); durationStr != "" {
		if d, err := strconv.Atoi(durationStr); err == nil && d > 0 {
			cpuDuration = d
		}
	}
	
	samplingMode := os.Getenv("PPROF_SAMPLING_MODE")
	samplingInterval := 60
	if intervalStr := os.Getenv("PPROF_SAMPLING_INTERVAL"); intervalStr != "" {
		if i, err := strconv.Atoi(intervalStr); err == nil && i > 0 {
			samplingInterval = i
		}
	}
	
	log.Printf("[pprofview] CPU sampling duration: %d seconds", cpuDuration)
	log.Printf("[pprofview] Sampling mode: %s", samplingMode)
	
	// Start different sampling logic based on sampling mode
	if samplingMode == "LOOP" {
		log.Printf("[pprofview] Loop sampling interval: %d seconds", samplingInterval)
		startLoopSampling(cpuDuration, samplingInterval)
	} else {
		startSingleSampling(cpuDuration)
	}
}

// startSingleSampling Single sampling mode
func startSingleSampling(cpuDuration int) {
	go func() {
		time.Sleep(time.Duration(cpuDuration) * time.Second)
		log.Println("[pprofview] Sampling timeout, saving pprof data...")
		if pprofCleanupFunc != nil {
			pprofCleanupFunc()
			pprofCleanupFunc = nil
		}
	}()
}

// startLoopSampling Loop sampling mode
func startLoopSampling(cpuDuration int, interval int) {
	go func() {
		sampleCount := 0
		for {
			sampleCount++
			log.Printf("[pprofview] Starting sample #%d...", sampleCount)
			
			// Wait for sampling duration
			time.Sleep(time.Duration(cpuDuration) * time.Second)
			
			log.Printf("[pprofview] Sample #%d completed, saving data...", sampleCount)
			
			// Save current sampling data
			if pprofCleanupFunc != nil {
				pprofCleanupFunc()
			}
			
			log.Printf("[pprofview] Waiting %d seconds before next sample...", interval)
			
			// Wait for sampling interval
			time.Sleep(time.Duration(interval) * time.Second)
			
			// Restart CPU profiling and trace (if enabled)
			restartProfiling()
		}
	}()
}

// restartProfiling Restart profiling
func restartProfiling() {
	// Restart CPU profiling
	if os.Getenv("PPROF_ENABLE_CPU") == "true" && pprofOutputDir != "" {
		cpuFilePath := filepath.Join(pprofOutputDir, fmt.Sprintf("cpu_%d.pprof", time.Now().Unix()))
		f, err := os.Create(cpuFilePath)
		if err != nil {
			log.Printf("[pprofview] Cannot create CPU profile file: %v", err)
		} else {
			if err := pprof.StartCPUProfile(f); err != nil {
				log.Printf("[pprofview] Cannot start CPU profiling: %v", err)
				f.Close()
			} else {
				pprofCpuFile = f
				log.Printf("[pprofview] CPU profiling restarted: %s", cpuFilePath)
			}
		}
	}
	
	// Restart trace
	if os.Getenv("PPROF_ENABLE_TRACE") == "true" && pprofOutputDir != "" {
		traceFilePath := filepath.Join(pprofOutputDir, fmt.Sprintf("trace_%d.out", time.Now().Unix()))
		f, err := os.Create(traceFilePath)
		if err != nil {
			log.Printf("[pprofview] Cannot create trace file: %v", err)
		} else {
			if err := trace.Start(f); err != nil {
				log.Printf("[pprofview] Cannot start trace: %v", err)
				f.Close()
			} else {
				pprofTraceFile = f
				log.Printf("[pprofview] Trace restarted: %s", traceFilePath)
			}
		}
	}
}



// writePprofProfiles Write other types of profiles
func writePprofProfiles(outputDir string) {
	// Heap profiling
	if os.Getenv("PPROF_ENABLE_HEAP") == "true" {
		heapFile := filepath.Join(outputDir, "heap.pprof")
		f, err := os.Create(heapFile)
		if err == nil {
			runtime.GC()
			if err := pprof.WriteHeapProfile(f); err == nil {
				log.Printf("[pprofview] Heap profiling completed: %s", heapFile)
			}
			f.Close()
		}
	}
	
	// Goroutine profiling
	if os.Getenv("PPROF_ENABLE_GOROUTINE") == "true" {
		goroutineFile := filepath.Join(outputDir, "goroutine.pprof")
		f, err := os.Create(goroutineFile)
		if err == nil {
			if err := pprof.Lookup("goroutine").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] Goroutine profiling completed: %s", goroutineFile)
			}
			f.Close()
		}
	}
	
	// Block profiling
	if os.Getenv("PPROF_ENABLE_BLOCK") == "true" {
		blockFile := filepath.Join(outputDir, "block.pprof")
		f, err := os.Create(blockFile)
		if err == nil {
			if err := pprof.Lookup("block").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] Block profiling completed: %s", blockFile)
			}
			f.Close()
		}
	}
	
	// Mutex profiling
	if os.Getenv("PPROF_ENABLE_MUTEX") == "true" {
		mutexFile := filepath.Join(outputDir, "mutex.pprof")
		f, err := os.Create(mutexFile)
		if err == nil {
			if err := pprof.Lookup("mutex").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] Mutex profiling completed: %s", mutexFile)
			}
			f.Close()
		}
	}
	
	// Allocations profiling
	if os.Getenv("PPROF_ENABLE_ALLOCS") == "true" {
		allocsFile := filepath.Join(outputDir, "allocs.pprof")
		f, err := os.Create(allocsFile)
		if err == nil {
			runtime.GC()
			if err := pprof.Lookup("allocs").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] Allocations profiling completed: %s", allocsFile)
			}
			f.Close()
		}
	}
	
	// Thread creation profiling
	if os.Getenv("PPROF_ENABLE_THREADCREATE") == "true" {
		threadCreateFile := filepath.Join(outputDir, "threadcreate.pprof")
		f, err := os.Create(threadCreateFile)
		if err == nil {
			if err := pprof.Lookup("threadcreate").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] Thread creation profiling completed: %s", threadCreateFile)
			}
			f.Close()
		}
	}
}
