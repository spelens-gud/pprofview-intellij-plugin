// Code generated by pprofview plugin. DO NOT EDIT.
// This file is automatically injected to enable pprof profiling.

package main

import (
	"fmt"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"runtime/trace"
	"strconv"
	"syscall"
	"time"
)

var (
	pprofCleanupFunc func()
	pprofCpuFile     *os.File
	pprofTraceFile   *os.File
	pprofOutputDir   string
)

func init() {	
	outputDir := os.Getenv("PPROF_OUTPUT_DIR")
	if outputDir == "" {
		log.Println("[pprofview] 未设置 PPROF_OUTPUT_DIR 环境变量，跳过 pprof 采集")
		return
	}
	
	pprofOutputDir = outputDir
	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Printf("[pprofview] 无法创建输出目录: %v", err)
		return
	}
	
	// Set sampling rates
	if memRateStr := os.Getenv("PPROF_MEM_RATE"); memRateStr != "" {
		if memRate, err := strconv.Atoi(memRateStr); err == nil && memRate > 0 {
			runtime.MemProfileRate = memRate
			log.Printf("[pprofview] 内存采样率: %d", memRate)
		}
	}
	
	if blockRateStr := os.Getenv("PPROF_BLOCK_RATE"); blockRateStr != "" {
		if blockRate, err := strconv.Atoi(blockRateStr); err == nil && blockRate > 0 {
			runtime.SetBlockProfileRate(blockRate)
			log.Printf("[pprofview] 阻塞采样率: %d", blockRate)
		}
	}
	
	if mutexFractionStr := os.Getenv("PPROF_MUTEX_FRACTION"); mutexFractionStr != "" {
		if mutexFraction, err := strconv.Atoi(mutexFractionStr); err == nil && mutexFraction > 0 {
			runtime.SetMutexProfileFraction(mutexFraction)
			log.Printf("[pprofview] 互斥锁采样率: %d", mutexFraction)
		}
	}
	
	// CPU profiling
	if os.Getenv("PPROF_ENABLE_CPU") == "true" {
		cpuFilePath := filepath.Join(outputDir, "cpu.pprof")
		f, err := os.Create(cpuFilePath)
		if err != nil {
			log.Printf("[pprofview] 无法创建 CPU profile 文件: %v", err)
		} else {
			if err := pprof.StartCPUProfile(f); err != nil {
				f.Close()
			} else {
				pprofCpuFile = f
			}
		}
	}
	
	// Execution trace
	if os.Getenv("PPROF_ENABLE_TRACE") == "true" {
		traceFilePath := filepath.Join(outputDir, "trace.out")
		f, err := os.Create(traceFilePath)
		if err != nil {
			log.Printf("[pprofview] 无法创建 trace 文件: %v", err)
		} else {
			if err := trace.Start(f); err != nil {
				f.Close()
			} else {
				pprofTraceFile = f
			}
		}
	}
	
	// Set cleanup function
	pprofCleanupFunc = func() {
		log.Println("[pprofview] 开始保存 pprof 数据...")
		if pprofCpuFile != nil {
			pprof.StopCPUProfile()
			pprofCpuFile.Close()
			log.Printf("[pprofview] CPU profiling 已完成")
		}
		if pprofTraceFile != nil {
			trace.Stop()
			pprofTraceFile.Close()
			log.Printf("[pprofview] Trace 已完成")
		}
		writePprofProfiles(pprofOutputDir)
		log.Println("[pprofview] 所有 pprof 数据已保存")
	}
	
	// Capture interrupt signals
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	
	go func() {
		<-sigChan
		log.Println("[pprofview] 收到退出信号，正在保存 pprof 数据...")
		if pprofCleanupFunc != nil {
			pprofCleanupFunc()
		}
		os.Exit(0)
	}()
	
	// Get sampling configuration
	cpuDuration := 30
	if durationStr := os.Getenv("PPROF_CPU_DURATION"); durationStr != "" {
		if d, err := strconv.Atoi(durationStr); err == nil && d > 0 {
			cpuDuration = d
		}
	}
	
	samplingMode := os.Getenv("PPROF_SAMPLING_MODE")
	samplingInterval := 60
	if intervalStr := os.Getenv("PPROF_SAMPLING_INTERVAL"); intervalStr != "" {
		if i, err := strconv.Atoi(intervalStr); err == nil && i > 0 {
			samplingInterval = i
		}
	}
	
	log.Printf("[pprofview] CPU 采样持续时间: %d 秒", cpuDuration)
	log.Printf("[pprofview] 采样模式: %s", samplingMode)
	
	// Start different sampling logic based on sampling mode
	if samplingMode == "LOOP" {
		log.Printf("[pprofview] 循环采样间隔: %d 秒", samplingInterval)
		startLoopSampling(cpuDuration, samplingInterval)
	} else {
		startSingleSampling(cpuDuration)
	}
}

// startSingleSampling Single sampling mode
func startSingleSampling(cpuDuration int) {
	go func() {
		time.Sleep(time.Duration(cpuDuration) * time.Second)
		log.Println("[pprofview] 采样时间到，保存 pprof 数据...")
		if pprofCleanupFunc != nil {
			pprofCleanupFunc()
			pprofCleanupFunc = nil
		}
	}()
}

// startLoopSampling Loop sampling mode
func startLoopSampling(cpuDuration int, interval int) {
	go func() {
		sampleCount := 0
		for {
			sampleCount++
			log.Printf("[pprofview] 开始第 %d 次采样...", sampleCount)
			
			// Wait for sampling duration
			time.Sleep(time.Duration(cpuDuration) * time.Second)
			
			log.Printf("[pprofview] 第 %d 次采样完成，保存数据...", sampleCount)
			
			// Save current sampling data
			if pprofCleanupFunc != nil {
				pprofCleanupFunc()
			}
			
			log.Printf("[pprofview] 等待 %d 秒后开始下一次采样...", interval)
			
			// Wait for sampling interval
			time.Sleep(time.Duration(interval) * time.Second)
			
			// Restart CPU profiling and trace (if enabled)
			restartProfiling()
		}
	}()
}

// restartProfiling Restart profiling
func restartProfiling() {
	// Restart CPU profiling
	if os.Getenv("PPROF_ENABLE_CPU") == "true" && pprofOutputDir != "" {
		cpuFilePath := filepath.Join(pprofOutputDir, fmt.Sprintf("cpu_%d.pprof", time.Now().Unix()))
		f, err := os.Create(cpuFilePath)
		if err != nil {
			log.Printf("[pprofview] 无法创建 CPU profile 文件: %v", err)
		} else {
			if err := pprof.StartCPUProfile(f); err != nil {
				log.Printf("[pprofview] 无法启动 CPU profiling: %v", err)
				f.Close()
			} else {
				pprofCpuFile = f
				log.Printf("[pprofview] CPU profiling 已重新启动: %s", cpuFilePath)
			}
		}
	}
	
	// Restart trace
	if os.Getenv("PPROF_ENABLE_TRACE") == "true" && pprofOutputDir != "" {
		traceFilePath := filepath.Join(pprofOutputDir, fmt.Sprintf("trace_%d.out", time.Now().Unix()))
		f, err := os.Create(traceFilePath)
		if err != nil {
			log.Printf("[pprofview] 无法创建 trace 文件: %v", err)
		} else {
			if err := trace.Start(f); err != nil {
				log.Printf("[pprofview] 无法启动 trace: %v", err)
				f.Close()
			} else {
				pprofTraceFile = f
				log.Printf("[pprofview] Trace 已重新启动: %s", traceFilePath)
			}
		}
	}
}



// writePprofProfiles Write other types of profiles
func writePprofProfiles(outputDir string) {
	// Heap profiling
	if os.Getenv("PPROF_ENABLE_HEAP") == "true" {
		heapFile := filepath.Join(outputDir, "heap.pprof")
		f, err := os.Create(heapFile)
		if err == nil {
			runtime.GC()
			if err := pprof.WriteHeapProfile(f); err == nil {
				log.Printf("[pprofview] 堆内存 profiling 已完成: %s", heapFile)
			}
			f.Close()
		}
	}
	
	// Goroutine profiling
	if os.Getenv("PPROF_ENABLE_GOROUTINE") == "true" {
		goroutineFile := filepath.Join(outputDir, "goroutine.pprof")
		f, err := os.Create(goroutineFile)
		if err == nil {
			if err := pprof.Lookup("goroutine").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] 协程 profiling 已完成: %s", goroutineFile)
			}
			f.Close()
		}
	}
	
	// Block profiling
	if os.Getenv("PPROF_ENABLE_BLOCK") == "true" {
		blockFile := filepath.Join(outputDir, "block.pprof")
		f, err := os.Create(blockFile)
		if err == nil {
			if err := pprof.Lookup("block").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] 阻塞 profiling 已完成: %s", blockFile)
			}
			f.Close()
		}
	}
	
	// Mutex profiling
	if os.Getenv("PPROF_ENABLE_MUTEX") == "true" {
		mutexFile := filepath.Join(outputDir, "mutex.pprof")
		f, err := os.Create(mutexFile)
		if err == nil {
			if err := pprof.Lookup("mutex").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] 互斥锁 profiling 已完成: %s", mutexFile)
			}
			f.Close()
		}
	}
	
	// Allocations profiling
	if os.Getenv("PPROF_ENABLE_ALLOCS") == "true" {
		allocsFile := filepath.Join(outputDir, "allocs.pprof")
		f, err := os.Create(allocsFile)
		if err == nil {
			runtime.GC()
			if err := pprof.Lookup("allocs").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] 内存分配 profiling 已完成: %s", allocsFile)
			}
			f.Close()
		}
	}
	
	// Thread creation profiling
	if os.Getenv("PPROF_ENABLE_THREADCREATE") == "true" {
		threadCreateFile := filepath.Join(outputDir, "threadcreate.pprof")
		f, err := os.Create(threadCreateFile)
		if err == nil {
			if err := pprof.Lookup("threadcreate").WriteTo(f, 0); err == nil {
				log.Printf("[pprofview] 线程创建 profiling 已完成: %s", threadCreateFile)
			}
			f.Close()
		}
	}
}
